<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Simple Snake GAme</title>
	<style type="text/css">
		canvas {
			display: block;
			position: absolute;
			border: 1px solid #000;
			margin: auto;
			top: 0;
			bottom: 0;
			right: 0;
			left: 0;
		}

	</style>
</head>
<body>
	<script type="text/javascript">
// constants
var is_game_over;
var COLS=26, ROWS=26;
var current_snake;

var EMPTY=0, SNAKE_P = 1, SNAKE_G =2, SNAKE_C = 3, SNAKE_R = 4;
var FRUIT=2;

var LEFT=0, UP=1, RIGHT=2, DOWN=3;
//keycodes
var KEY_LEFT=37, KEY_UP=38, KEY_RIGHT=39, KEY_DOWN = 40, KEY_SPACE=32;


var grid = {
	width: null,
	height: null,
	_grid: null,

	init: function(d, c, r){
		this.width = c;
		this.height = r;
		this._grid = [];

		for (var x=0; x < c; x++){
			this._grid.push([]);
			for (var y=0; y < r; y++){
				this._grid[x].push(d);
			}
		}
	},
	set: function(val, x, y){
		this._grid[x][y] = val;
	},
	get: function(x, y){
		return this._grid[x][y];
	}
};

var snake = {
	direction: null,
	last: null,
	_queue: null,

	init: function(d, x, y){
		this.direction = d;

		this._queue = [];
		this.insert(x, y);
	},
	insert: function(x, y){
		this._queue.unshift({x: x, y:y});
		this.last = this._queue[0];
	},
	remove: function(){
		return this._queue.pop();
	}
}

function setFood(){
	var empty = [];
	for (var x=0; x < grid.width; x++){
		for (var y=0; y < grid.height; y++){
			if (grid.get(x,y) === EMPTY) {
				empty.push({x:x, y:y})
			}
		}
	}
	var random_index = Math.floor(Math.random()*empty.length);
	var randpos = empty[random_index];
	grid.set(FRUIT, randpos.x, randpos.y);

	// random_index = Math.floor(Math.random()*empty.length);
	// randpos = empty[random_index];
	// grid.set(FRUIT, randpos.x, randpos.y);
}
// Game objects
var canvas, ctx, keystate, frames, score, is_game_over = false;

// functions
function main(){
	canvas = document.createElement("canvas");
	canvas.width = COLS*20;
	canvas.height = ROWS*20;
	ctx = canvas.getContext("2d");
	document.body.appendChild(canvas);

ctx.font = "13px Times";
	frames = 0;
	keystate = {};
	document.addEventListener("keydown", function(evt) {
		keystate[evt.keyCode] = true;
	});
	document.addEventListener("keyup", function(evt) {
		delete keystate[evt.keyCode];

	});

	init();
	loop();
}
function init(){
	grid.init(EMPTY, COLS, ROWS);


	score = 0;
	var sp = {dir: Math.floor(Math.random()*4),
				x: Math.floor(Math.random()*COLS), 
				y: Math.floor(Math.random()*ROWS)};

	if(sp.x <= 4 || sp.x >= 22 || sp.y <= 4 || sp.y >= 22) {
		sp.x = sp.y = 10;
	}
				
	snake.init(sp.dir, sp.x, sp.y);

	current_snake = Math.ceil(Math.random() * 4);

	switch(current_snake){
		case SNAKE_P:
			grid.set(SNAKE_P, sp.x, sp.y);
			break;
		case SNAKE_G:
			grid.set(SNAKE_G, sp.x, sp.y);
			break;
		case SNAKE_C:
			grid.set(SNAKE_C, sp.x, sp.y);
			break;
		case SNAKE_R:
			grid.set(SNAKE_R, sp.x, sp.y);
			break;
	}

	setFood();
	// is_game_over = false;
}

function loop(){
	update();
	draw();

	window.requestAnimationFrame(loop, canvas);
}
function update(){
	frames++;

	if (keystate[KEY_LEFT] && snake.direction!== RIGHT) snake.direction = LEFT;
	if (keystate[KEY_UP] && snake.direction!==  DOWN) snake.direction = UP;
	if (keystate[KEY_DOWN] && snake.direction!== UP ) snake.direction = DOWN;
	if (keystate[KEY_RIGHT] && snake.direction!== LEFT) snake.direction = RIGHT;
	if (keystate[KEY_SPACE]) is_game_over = false;

	if (frames%2 ===0) {
		var nx = snake.last.x;
		var ny = snake.last.y;

		switch (snake.direction){
			case LEFT:
				nx--;
				break;
			case UP:
				ny--;
				break;
			case RIGHT:
				nx++;
				break;
			case DOWN:
				ny++;
				break;
		}

		if (0 > nx || nx > grid.width -  1 ||
			0 > ny || ny > grid.height - 1 || 
			grid.get(nx, ny) === current_snake) {
				is_game_over = true;
				return init();
		}

		if (grid.get(nx, ny) === FRUIT){
			var tail = {x:nx, y:ny};
			score++;
			setFood();
		} else {
			var tail = snake.remove();
			grid.set(EMPTY, tail.x, tail.y);
			tail.x = nx;
			tail.y = ny;
		}

		switch(current_snake){
		case SNAKE_P:
			grid.set(SNAKE_P, tail.x, tail.y);
			break;
		case SNAKE_G:
			grid.set(SNAKE_G, tail.x, tail.y);
			break;
		case SNAKE_C:
			grid.set(SNAKE_C, tail.x, tail.y);
			break;
		case SNAKE_R:
			grid.set(SNAKE_R, tail.x, tail.y);
			break;
	}


		snake.insert(tail.x, tail.y);
	}
}
function draw(){
	var tw = canvas.width/grid.width;
	var th = canvas.height/grid.height;
	if (!is_game_over){
		for (var x=0; x < grid.width; x++){
			for (var y=0; y < grid.height; y++){
				switch(grid.get(x,y)) {
					case EMPTY:
						ctx.fillStyle = "#fff";
						console.log("empty");
						break;
					case SNAKE_P:
					// brown
						ctx.fillStyle  = "#deb887";
						console.log("brown");
						break;
					case SNAKE_G:
					// black
						ctx.fillStyle = "#000";
						console.log("black");
						break;
					case SNAKE_C:
					// green
						ctx.fillStyle = "#f0f";
						console.log("green");
						break;
					case SNAKE_R:
					// blue
						ctx.fillStyle = "#00f";
						console.log("blue");
						break;
					case FRUIT:
						ctx.fillStyle  = "#f00";
						console.log("red");
						break;
				}
				ctx.fillRect(x*tw, y*th, tw, th);
			}
			
			ctx.fillStyle = "#000";
			ctx.fillText("SCORE: " + score, 10, canvas.height - 10);
		}
	} else if (is_game_over){
		ctx.font = "20px Times";
		ctx.fillStyle = "#000";
		var game_over_string = "GAME OVER";
		var repeat = ", press spacebar to try again";
		ctx.fillText(game_over_string + repeat, canvas.width / 2 - game_over_string.length*18, canvas.height /2 );
	}
}
main();
	</script>
//
</body>
